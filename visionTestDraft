# Vision Machine draft

import statistics  # For statistics.median()
import cv2  # OpenCV
import numpy as np  # For SVM
import os  # For working with files
import datetime  # For time and date stamps
import time
import math
from pkg_resources import require


# Tells you which color group a pixel belongs in. The choices are Red, Blue, Green, Yellow, Pink, Gray, Black, and White
def color_classifier(red, green, blue):
    median = statistics.median([red, blue, green])

    # If all colors are within 10 of each other
    if blue <= (median + 10) and blue >= (median - 10) and green <= (median + 10) and green >= (median - 10) and red <= (median + 10) and red >= (median - 10):
        if median <= 50:
            return "black"
        elif median >= 250:
            return "white"
        else:
            return "gray"
    # If blue and green are within 10 of each other and are the top two numbers
    elif (max([red,blue,green]) == blue or max([red,blue,green]) == green) and (blue <= (green + 10) and blue >= (green - 10)):
        if blue >= 30 and green >= 30:
            return "blue"
        else:
            return "black"
    # If red and blue are within 10 of each other and are the top two numbers
    elif (max([red, blue, green]) == red or max([red, blue, green]) == blue) and (blue <= (red + 10) and blue >= (red - 10)):
        if red >= 40 and blue >= 40:
            return "pink"
        else:
            return "black"
    # If red and green are within 10 of each other and are the top two numbers
    elif (max([red, blue, green]) == red or max([red, blue, green]) == green) and (green <= (red + 10) and green >= (red - 10)):
        if red >= 80 and green >= 80:
            return "yellow"
        else:
            return "black"
    # If red is highest
    elif max([red, blue, green]) == red:
        if min([blue, green]) <= (red - 20):
            return "red"
        else:
            return "gray"
    # If green is highest
    elif max([red, blue, green]) == green:
        if min([red, blue, green]) <= (green - 20):
            return "green"
        else:
            return "gray"
    # If blue is highest
    elif max([red, blue, green]) == blue:
        if min([red, blue, green]) <= (blue - 20):
            return "blue"
        else:
            return "gray"


def counting_colors(photoPath):
    redCount = 0
    blueCount = 0
    greenCount = 0
    yellowCount = 0
    pinkCount = 0
    grayCount = 0
    blackCount = 0
    whiteCount = 0

    photo = cv2.imread(photoPath,1)

    if photo.size != 230400:
        photo = cv2.resize(photo, (240,320))

    height, width = photo.shape[:2]

    for x in range(height):
        for y in range(width):
            colorFound = color_classifier(photo[x, y, 2],photo[x, y, 1],photo[x, y, 0])

            if(colorFound == "red"):
                redCount = redCount + 1
            elif(colorFound == "blue"):
                blueCount = blueCount + 1
            elif(colorFound == "green"):
                greenCount = greenCount + 1
            elif(colorFound == "yellow"):
                yellowCount = yellowCount + 1
            elif(colorFound == "pink"):
                pinkCount = pinkCount + 1
            elif(colorFound == "gray"):
                grayCount = grayCount + 1
            elif(colorFound == "black"):
                blackCount = blackCount + 1
            elif(colorFound == "white"):
                whiteCount = whiteCount + 1

    colorCount = [min_max_normalization(redCount),min_max_normalization(blueCount),min_max_normalization(greenCount),min_max_normalization(yellowCount),min_max_normalization(pinkCount),min_max_normalization(grayCount),min_max_normalization(blackCount),min_max_normalization(whiteCount)]

    return colorCount


def process_image(file, testList = [0]):
    if (file.split(".")[1:] == ['png'] or file.split(".")[1:] == ['jpg']):

        photoData = counting_colors(file)
        file = file.replace(".", "_")
        nickname, temp, humidity, dewPoint, time, date, extension = file.split("_")
        temp = temp.replace("p", ".")
        humidity = humidity.replace("p", ".")
        dewPoint = dewPoint.replace("p", ".")
        photoData.append(min_max_normalization(float(temp)))
        photoData.append(min_max_normalization(float(humidity)))
        photoData.append(min_max_normalization(float(dewPoint)))
        photoData.append(min_max_normalization(int(time)))
        photoData.append(min_max_normalization(int(date)))

        if testList != [0]:
            testList.append(photoData)
        print(photoData)
        return photoData


def process_image_folder(fpath,testList = [-1], labelList = [-1], catPath = ""):

    for file in os.listdir(fpath + catPath):
        photoData = process_image(fpath + catPath + "/" + file)

        if catPath != "" and photoData != None:
            if catPath == "/clear":
                labelList.append(0)
            elif catPath == "/foggy":
                labelList.append(1)
            elif catPath == "/smoky":
                labelList.append(2)
            elif catPath == "/anomaly":
                labelList.append(3)

            testList.append(photoData)


def process_test_data(folderPath):
    allTestingData = []
    labels = []

    if os.path.isdir(folderPath):
        if os.path.isdir(folderPath + "/clear") and os.path.isdir(folderPath + "/foggy") and os.path.isdir(folderPath + "/smoky") and os.path.isdir(folderPath + "/anomaly"):
            print("Attempting to extract data from images... Please be patient!\n")
            process_image_folder(folderPath, allTestingData, labels, "/clear")
            print("clear")
            process_image_folder(folderPath, allTestingData, labels, "/foggy")
            print("foggy")
            process_image_folder(folderPath, allTestingData, labels, "/smoky")
            print("clear")
            process_image_folder(folderPath, allTestingData, labels, "/anomaly")
            print("Data extraction complete.")
            return allTestingData,labels
        else:
            print("ERROR! Test data not complete! Folders needed: clear, foggy, smoky, anomaly. This is case sensitive!")
    else:
        print("ERROR! Could not find test data folder!")


def classify_image_from_camera():
    os.popen("raspistill -t 2000 -o -n latestImage.png") #Take image with pi camera

    # ENTER CODE HERE TO GET TEMP AND HUMIDITY FROM PI

    dataFromImage = counting_colors("latestImage.png")
    # dataFromImage.append(float(ENTER CODE TO GET TEMP))
    # dataFromImage.append(float(ENTER CODE TO GET HUMIDITY))
    # dataFromImage.append(float(ENTER CODE TO GET DEW POINT))
    dataFromImage.append(datetime.datetime.now().strftime("%H%M")) # Append time in 24 hour format with no colin
    dataFromImage.append(datetime.datetime.now().strftime("%m%d%y")) # Append date in MMDDYY format

    return dataFromImage


def classify_images_from_folder(folderPath):
    if(os.path.isdir(folderPath)):
        testingData = []
        process_image_folder(folderPath,testingData)
        return testingData
    else:
        print("Error! Test file not found!")


def train_svm(trainingData,labels):
    svm = cv2.ml.SVM_create()
    print("Training SVM, this may take a while.")

    svm.setKernel(cv2.ml.SVM_RBF)
    svm.setType(cv2.ml.SVM_C_SVC)
    svm.setC(2.67)
    svm.setGamma(5)

    svm.train(np.array(trainingData, np.float32), cv2.ml.ROW_SAMPLE, np.array(labels, np.int32))
    print("Training complete.")
    svm.save('svm_data.dat')


def predict_using_svm(imageData):
    dataList = []
    dataList.append(imageData)
    svm = cv2.ml.SVM_load('svm_data.dat')
    return(int(svm.predict(np.asarray(dataList,np.float32))[1]))


def min_max_normalization(value):
    return (((value - 0) / (500000 - 0)) * (1 - (-1)) + (-1))


def prediction_test(folder):
    for photo in os.listdir(folder):
        if (photo.split(".")[1:] == ['png'] or photo.split(".")[1:] == ['jpg']):
            print("Processing " + photo)

            prediction = predict_using_svm(process_image(folder + photo))
            image = cv2.imread(folder + photo)

            if prediction == 0:
                print("Image classified as clear")
                cv2.imshow("Clear", image)
            elif prediction == 1:
                print("Image classified as foggy")
                cv2.imshow("Foggy", image)
            elif prediction == 2:
                print("Image classified as smoky")
                cv2.imshow("Smoky", image)
            else:
                print("Image classified as an anomaly")
                cv2.imshow("Anomaly", image)

            cv2.waitKey(1)
            time.sleep(5)
            cv2.destroyAllWindows()


def find_distance_to_object(image, height_of_lens, distance_in_pixels):
    photo = cv2.imread(image)
    height, width = photo.shape[:2]
    angle_of_view = math.degrees(2 * math.atan(3.76/(2*3.60)))  #Raspberry pi v1 cam assummed
    angle_to_object = (angle_of_view/(math.sqrt(((height**2) + (width**2)))) * distance_in_pixels)
    third_angle = 180 - (90 + angle_to_object)
    print(height)
    print(width)
    print(angle_of_view)
    print(angle_to_object)
    print(third_angle)
    return height_of_lens / math.tan(third_angle)



#  trainingList, labelsList = process_test_data("testData/medford")
# train_svm(trainingList,labelsList) #Train and test SVM
prediction_test("test/")
# print(find_distance_to_object('C:/Temp/laser.png',6.5,3))
